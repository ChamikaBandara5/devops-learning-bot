"""
üìù DevOps Interview Q&A Module
Curated interview questions with quiz mode
"""

import random

QUESTIONS = {
    "docker": [
        {
            "q": "What is the difference between a Docker image and a container?",
            "a": "An **image** is a read-only template with instructions for creating a container. A **container** is a runnable instance of an image.",
            "a_si": "**Image** ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö container ‡∂ë‡∂ö‡∂ö‡∑ä ‡∑Ñ‡∂Ø‡∂±‡∑ä‡∂± instructions ‡∂≠‡∑í‡∂∫‡∑ô‡∂± read-only template ‡∂ë‡∂ö‡∂ö‡∑ä. **Container** ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö image ‡∂ë‡∂ö‡∂ö runnable instance ‡∂ë‡∂ö‡∂ö‡∑ä."
        },
        {
            "q": "What is a Dockerfile?",
            "a": "A **Dockerfile** is a text file with instructions to build a Docker image. It contains commands like FROM, RUN, COPY, CMD.",
            "a_si": "**Dockerfile** ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö Docker image ‡∂ë‡∂ö‡∂ö‡∑ä build ‡∂ö‡∂ª‡∂±‡∑ä‡∂± instructions ‡∂≠‡∑í‡∂∫‡∑ô‡∂± text file ‡∂ë‡∂ö‡∂ö‡∑ä."
        },
        {
            "q": "What is Docker Compose?",
            "a": "**Docker Compose** is a tool for defining and running multi-container applications using a YAML file (docker-compose.yml).",
            "a_si": "**Docker Compose** ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö multi-container applications run ‡∂ö‡∂ª‡∂±‡∑ä‡∂± use ‡∂ö‡∂ª‡∂± tool ‡∂ë‡∂ö‡∂ö‡∑ä."
        },
        {
            "q": "What is the difference between CMD and ENTRYPOINT?",
            "a": "**CMD** provides default arguments that can be overridden. **ENTRYPOINT** defines the main command that always runs.",
            "a_si": "**CMD** default arguments ‡∂Ø‡∑ô‡∂±‡∑Ä‡∑è (override ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä). **ENTRYPOINT** main command define ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What are Docker volumes?",
            "a": "**Volumes** are the preferred way to persist data generated by containers. They are managed by Docker and survive container restarts.",
            "a_si": "**Volumes** k‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö container data persist ‡∂ö‡∂ª‡∂±‡∑ä‡∂± best way ‡∂ë‡∂ö. Docker manage ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        }
    ],
    "kubernetes": [
        {
            "q": "What is a Kubernetes Pod?",
            "a": "A **Pod** is the smallest deployable unit in K8s. It can contain one or more containers that share storage and network.",
            "a_si": "**Pod** ‡∂ë‡∂ö‡∂ö‡∑ä ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö K8s ‡∑Ä‡∂Ω deploy ‡∂ö‡∂ª‡∂±‡∑ä‡∂± ‡∂¥‡∑î‡∑Ö‡∑î‡∑Ä‡∂±‡∑ä ‡∂ö‡∑î‡∂©‡∑è‡∂∏ unit ‡∂ë‡∂ö."
        },
        {
            "q": "What is a Deployment in Kubernetes?",
            "a": "A **Deployment** manages ReplicaSets and provides declarative updates, rolling updates, and rollback capabilities.",
            "a_si": "**Deployment** ‡∂ë‡∂ö‡∂ö‡∑ä ReplicaSets manage ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è, rolling updates ‡∑É‡∑Ñ rollback ‡∂Ø‡∑ô‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What is the difference between a Service and an Ingress?",
            "a": "A **Service** exposes pods internally (ClusterIP) or externally (LoadBalancer). **Ingress** manages external HTTP/HTTPS routing with URL-based rules.",
            "a_si": "**Service** pods expose ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. **Ingress** external HTTP routing manage ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What is a ConfigMap?",
            "a": "A **ConfigMap** stores non-confidential configuration data as key-value pairs that can be consumed by pods.",
            "a_si": "**ConfigMap** non-confidential config data store ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What is a StatefulSet?",
            "a": "A **StatefulSet** manages stateful applications with stable network IDs and persistent storage. Used for databases.",
            "a_si": "**StatefulSet** stateful apps manage ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è - databases ‡∑Ä‡∂Ω‡∂ß use ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        }
    ],
    "cicd": [
        {
            "q": "What is CI/CD?",
            "a": "**CI** (Continuous Integration) automates code integration and testing. **CD** (Continuous Delivery/Deployment) automates deployment to production.",
            "a_si": "**CI** code integration automate ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. **CD** deployment automate ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What is a GitHub Actions workflow?",
            "a": "A YAML file that defines automated tasks triggered by events like push or pull request. Consists of jobs with steps.",
            "a_si": "Push/PR ‡∑Ä‡∂ú‡∑ö events ‡∑Ä‡∂Ω‡∑í‡∂±‡∑ä trigger ‡∑Ä‡∑ô‡∂± automated tasks define ‡∂ö‡∂ª‡∂± YAML file ‡∂ë‡∂ö‡∂ö‡∑ä."
        },
        {
            "q": "What is the difference between CI and CD?",
            "a": "**CI** focuses on automated testing and integration. **CD** focuses on automated deployment. CI happens before CD.",
            "a_si": "**CI** testing/integration. **CD** deployment. CI first, CD after."
        }
    ],
    "linux": [
        {
            "q": "What does the chmod command do?",
            "a": "**chmod** changes file permissions. Example: `chmod 755 file.sh` gives owner full access, others read+execute.",
            "a_si": "**chmod** file permissions change ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "How do you find a process using a specific port?",
            "a": "Use `lsof -i :PORT` or `netstat -tlnp | grep PORT` or `ss -tlnp | grep PORT`",
            "a_si": "`lsof -i :PORT` ‡∑Ñ‡∑ù `netstat -tlnp | grep PORT` use ‡∂ö‡∂ª‡∂±‡∑ä‡∂±."
        },
        {
            "q": "What is the difference between hard link and soft link?",
            "a": "**Hard link** points to inode (survives original deletion). **Soft/symbolic link** points to filename (breaks if original deleted).",
            "a_si": "**Hard link** inode ‡∂ë‡∂ö‡∂ß point ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. **Soft link** filename ‡∂ë‡∂ö‡∂ß point ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        }
    ],
    "devops": [
        {
            "q": "What is Infrastructure as Code (IaC)?",
            "a": "**IaC** is managing infrastructure using code/config files instead of manual processes. Tools: Terraform, Ansible, Pulumi.",
            "a_si": "**IaC** ‡∂ö‡∑í‡∂∫‡∂±‡∑ä‡∂±‡∑ö infrastructure code ‡∑Ä‡∂Ω‡∑í‡∂±‡∑ä manage ‡∂ö‡∂ª‡∂± ‡∂ë‡∂ö. Terraform, Ansible use ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What is the difference between Terraform and Ansible?",
            "a": "**Terraform** is for provisioning infrastructure (declarative). **Ansible** is for configuration management (procedural/declarative).",
            "a_si": "**Terraform** infrastructure provision ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è. **Ansible** configuration manage ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        },
        {
            "q": "What is GitOps?",
            "a": "**GitOps** uses Git as the single source of truth for declarative infrastructure. Changes are made via pull requests.",
            "a_si": "**GitOps** Git ‡∂ë‡∂ö infrastructure ‡∑É‡∂≥‡∑Ñ‡∑è single source of truth ‡∑Ä‡∑í‡∂Ø‡∑í‡∑Ñ‡∂ß use ‡∂ö‡∂ª‡∂±‡∑Ä‡∑è."
        }
    ]
}


class QuizSession:
    def __init__(self):
        self.current_question = None
        self.score = 0
        self.total = 0
        self.category = None
    
    def start(self, category: str = None):
        self.score = 0
        self.total = 0
        self.category = category
        return self.next_question()
    
    def next_question(self) -> dict:
        if self.category and self.category in QUESTIONS:
            questions = QUESTIONS[self.category]
        else:
            questions = [q for qs in QUESTIONS.values() for q in qs]
        
        self.current_question = random.choice(questions)
        self.total += 1
        
        return {
            "question": self.current_question["q"],
            "number": self.total,
            "category": self.category or "mixed"
        }
    
    def reveal_answer(self, lang: str = "en") -> str:
        if not self.current_question:
            return "No active question"
        
        answer_key = "a_si" if lang == "si" else "a"
        answer = self.current_question.get(answer_key, self.current_question["a"])
        
        return f"üìñ **Answer:**\n\n{answer}"
    
    def get_score(self) -> str:
        return f"üìä **Score:** {self.score}/{self.total}"


# Global quiz sessions per user
quiz_sessions = {}


def get_quiz_session(user_id: str) -> QuizSession:
    if user_id not in quiz_sessions:
        quiz_sessions[user_id] = QuizSession()
    return quiz_sessions[user_id]


def get_random_question(category: str = None, lang: str = "en") -> dict:
    """Get a random question"""
    if category and category in QUESTIONS:
        questions = QUESTIONS[category]
    else:
        questions = [q for qs in QUESTIONS.values() for q in qs]
    
    q = random.choice(questions)
    answer_key = "a_si" if lang == "si" else "a"
    
    return {
        "question": q["q"],
        "answer": q.get(answer_key, q["a"])
    }


def get_interview_menu():
    return """üìù **DevOps Interview Q&A**

**Categories:**
‚Ä¢ `/quiz docker` - Docker questions
‚Ä¢ `/quiz kubernetes` - K8s questions
‚Ä¢ `/quiz cicd` - CI/CD questions
‚Ä¢ `/quiz linux` - Linux questions
‚Ä¢ `/quiz devops` - DevOps concepts
‚Ä¢ `/quiz` - Random mix

**Commands:**
‚Ä¢ `/answer` - Show answer
‚Ä¢ `/next` - Next question
‚Ä¢ `/score` - See your score

üí° _50+ curated interview questions!_"""


def get_categories():
    return list(QUESTIONS.keys())
